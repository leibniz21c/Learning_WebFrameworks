py manage.py migrate 로 데이터 테이블 생성

question과 choice에 대한 데이터베이스 모델만들기 :
polls/models.py 에 코드작성
setting에서 pollsConfig 추가하고 
migration 만들기

py manage.py makemigrations polls

이후 Migration폴더에 프레임이 완성이되게되고

py manage.py migrate 명령어로 데이터베이스내에 테이블을 생성.

이후에 py manage.py shell 명령여기서 데이터를 세팅하기.
 
from polls.models import Choice, Question  # 두 모델을 사용하겠다.

Question.objects.all()  현재 Question 내의 모든 데이터를 가지고 와라.

from django.utils import timezone
q = Question(question_text="What's new?", pub_date=timezone.now()) 질문을 한개 추가하기.
q.save() 질문 데이터베이스에 저장하기

데이터 확인
q.id  q의 id반환 (id는 모델생성시 개발자가 만들지 않아도 자동으로 만들어주는 필드임.)
q.멤버변수


데이터 변경
q.question_text = "What's up?"
q.save()

데이터 확인이 용이하게 models에서 클래스에 __str__메소드를 추가하면 좋음.
ex)
class Question(models.Model):
    def __str__(self):
        return self.question_text

class Choice(models.Model)
    def __str__(self):
        return self.choice_text

이런식으로.

이후에 model에 변경된 사항을 저장하고 다시 shell을 실행 py manage.py shell
그럼 id가 표시된 방금에 비해 __str__메소드의 자동실행으로 What's new?라는 데이터 확인가능.

데이터 검색함수 :
Question.objects.filter(id=1) # id가 1인 데이터를 가져와라.
Question.objects.filter(question_text_startwith="What") #이런것도 가능 장고에서 지원하는 거임.

다음을 실습해봅시다.
>>> from polls.models import Choice, Question

# Make sure our __str__() addition worked.
>>> Question.objects.all()
<QuerySet [<Question: What's up?>]>

# Django provides a rich database lookup API that's entirely driven by
# keyword arguments.
>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith='What')
<QuerySet [<Question: What's up?>]>

# Get the question that was published this year.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

# Request an ID that doesn't exist, this will raise an exception.
>>> Question.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Question matching query does not exist.

# Lookup by a primary key is the most common case, so Django provides a
# shortcut for primary-key exact lookups. 프라이빗 키사용하는거. 이것도 장고에서 기본으로 설정해주는데 일단 id와 값이 같은듯.
# The following is identical to Question.objects.get(id=1).
>>> Question.objects.get(pk=1)
<Question: What's up?>

# Make sure our custom method worked.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# Give the Question a couple of Choices. The create call constructs a new
# Choice object, does the INSERT statement, adds the choice to the set
# of available choices and returns the new Choice object. Django creates
# a set to hold the "other side" of a ForeignKey relation
# (e.g. a question's choice) which can be accessed via the API.
>>> q = Question.objects.get(pk=1)

# Display any choices from the related object set -- none so far.
>>> q.choice_set.all()
<QuerySet []>

# Create three choices.
>>> q.choice_set.create(choice_text='Not much', votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text='The sky', votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)

# Choice objects have API access to their related Question objects.
>>> c.question
<Question: What's up?>

# And vice versa: Question objects get access to Choice objects.
>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

# The API automatically follows relationships as far as you need.
# Use double underscores to separate relationships.
# This works as many levels deep as you want; there's no limit.
# Find all Choices for any question whose pub_date is in this year
# (reusing the 'current_year' variable we created above).
>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

# Let's delete one of the choices. Use delete() for that.
>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
>>> c.delete()
